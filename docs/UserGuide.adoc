= Deadline Manager - User Guide
:site-section: UserGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:sectnumlevels: 6
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/CS2103-AY1819S1-W17-4/main

By: <<AboutUs#, CS2103-AY1819S1-W17-4>>      Since: `Sep 2018`      Licence: `MIT`

Morphed from: https://github.com/nus-cs2103-AY1819S1/addressbook-level4

== Introduction

Deadline Manager (DLM) is for those who *prefer to use a desktop app for keeping track of tasks*. More importantly, DLM is *optimized for those who prefer to work with a Command Line Interface* (CLI) while still having the benefits of a Graphical User Interface (GUI). If you can type fast, DLM can help you sort out your upcoming tasks faster than traditional GUI apps. Interested? Jump to the <<Quick Start>> to get started. Enjoy!

== Quick Start

The steps to quickly get started with the project are as follows -

.  Install Java version `9` or later on your Computer.
.  Download the latest `deadlinemanager.jar` link:{repoURL}/releases[here].
.  Copy the file to the folder you want to use as the home folder for your deadline manager.
.  Double-click the file to start the app. The GUI should appear in a few seconds.
+

image::Ui.png[width="790"]
+
.  Type the command in the command box and press kbd:[Enter] to execute it. +
e.g. typing *`help`* and pressing kbd:[Enter] will open the help window.

After starting the application, here are some sample commands you can try:

* *`list`* : lists all tasks in the deadline manager
* *`add n/v1 milestone d/2/10/2018 t/CS2103T p/1`* : adds a task named `v1 milestone` to the deadline manager
* *`delete 3`* : deletes the 3rd task shown in the current list
* *`exit`* : exits the app

You can refer to <<Features>> for the details of each command.

[[Features]]
== Features

====
*Command Format in User Guide*

* Words in `UPPER_CASE` are the parameters to be supplied by the user e.g. in `add n/NAME`, `NAME` is a parameter which can be used as `add n/Assignment 2`.
* Items in square brackets are optional e.g `n/NAME [t/TAG]` can be used as `n/Assignment 2 t/CS3230` or as `n/Assignment 2`.
* Items with `…`​ after them can be used multiple times including zero times e.g. `[t/TAG]...` can be used as `{nbsp}` (i.e. 0 times), `t/CS2103`, `t/CS2103 t/Project` etc.
====

====
*General Command Format*

Most commands follow the following format (characterized by `X/` parameter prefixes, where `X` is a single alphabet).  For these commands, unless otherwise specified, the following apply:

* Parameters can be in any order e.g. if the command specifies `n/NAME d/DEADLINE`, `d/DEADLINE n/NAME` is also acceptable.
* Parameters that contain spaces and `/` should be placed within quotes (either `'` or `"` are okay, but the opening and closing quotes must match) in order to prevent any ambiguity with other parameter prefixes.  (When there is no ambiguity then quotes are not necessary; however, this is not recommended.)
* Parameters containing `'` or `"` *must* be enclosed within the other type of quote (i.e. parameters containing `'` must be placed within `"`, and vice-versa).  It is not possible to use both `'` and `"` in the same parameter.
====

====
*Deadline Format*

* Deadline dates are accepted by various commands in Deadline Manager.  A deadline is only precise to a single day (it does not store the exact time within a day).  Deadline Manager is *not* timezone-aware.
* Dates are expressed in the format "D/M/YYYY".  Examples of valid dates are: 29/03/2018, 29/3/2018, 1/1/2018.  The year is _never_ interpreted relative to the current century: 29/3/12 is interpreted as 11 January 0012.
* Dates can also be expressed without the year, i.e. in the format "D/M".  Examples of valid dates in this format are: 29/03, 29/3, 1/1.  The current year (at the instant the command is executed) will be used.
* The minimum year allowed is 1 (i.e. non-positive years are not allowed).  The maximum year allowed is rather large (more than 6 digits, but limited by Java's internal `Date` representation), but it will definitely work with year values less than 1000000.
====

=== Viewing help : `help`
Displays the list of available functions for the user to use. It acts as a guide to help the user.

Format: `help`

=== Adding a task: `add`
Adds a task to the deadline manager +
Format: `add n/NAME [p/PRIORITY] [f/FREQUENCY] d/DEADLINE [t/TAG]...`

[TIP]
A task can have any number of tags (including 0)

****
* `DEADLINE` should be a date in the format DD/MM/YYYY. Examples of valid
dates are: 29/03/2018, 29/3/2018, 1/1/2018.
* `PRIORITY` should only be 0, 1, 2, 3, or 4.
The lower the number, the higher the priority of the task.
(1 = Highest Priority, 4 = Lowest Priority)
* `FREQUENCY` should be a non-negative integer (number of days).
Zero frequency denotes a non-recurring task.
Non-zero frequency denotes a recurring task.
****

[TIP]
You can have two tasks with the same attributes!

Examples:

* `add n/Assignment 2 d/1/1/2018 p/1` +
Adds a task with name `Assignment 2` with a deadline on 1st January 2018 with priority 1 (highest priority).
* `add n/v1 milestone d/9/10/2018 t/CS2103T t/Project p/2` +
Adds a task with name `v1 milestone` with a deadline on 9th October 2018 with priority 2 (second highest priority). It is additionally tagged with 2 tags: `CS2103T` and `Project`.

=== Completing a task : `complete`
Completes an existing task in the deadline manager.
If the task is not recurred (the frequency is equal to 0),
the task will be deleted.
Otherwise, the deadline will be moved
to the next occurrence. +
Format: `complete INDEX`

****
* `INDEX` refers to the index number shown in the displayed task list.
The index *must be a positive integer* 1, 2, 3, ...
****

Examples:

* `complete 1` +
Completes the first task in the displayed task list.

=== Listing all tasks : `list`

Shows a list of all tasks in the deadline manager. +
Format: `list`

=== Editing a task : `edit`
Edits an existing task in the deadline manager. +
Format: `edit INDEX [n/NAME] [p/PRIORITY] [f/FREQUENCY] [d/DEADLINE] [t/TAG]...`

****
* Edits the task at the specified `INDEX`. The index refers to the index number shown in the displayed task list. The index *must be a positive integer* 1, 2, 3, ...
* At least one of the optional fields must be provided.
* Existing values will be updated to the input values.
* When editing tags, the existing tags of the task will be removed i.e adding of tags is not cumulative.
* You can remove all the task's tags by typing `t/` without specifying any tags after it.
* The range of possible values for each argument of the edit command follows that of the add command.
****

Examples:

* `edit 1 d/3/10/2018` +
Edits the deadline of the 1st task to 3rd October 2018.
* `edit 2 n/v2 Milestone t/` +
Edits the name of the 2nd task to be `v2 Milestone` and clears all existing tags.
* `edit 1 p/1` +
Edits the priority of the 1st task to 1 (highest priority).

// tag::filter[]
// tag::filter-overview[]
=== Filtering a list of tasks: `filter`
Filters the current list of tasks with a specified filter expression. +
Format: `filter FILTER_EXPRESSION`

When this command is used, Deadline Manager will display only those tasks which satisfy the given filter expression.

[NOTE]
When executing any _modifying_ commands on a filtered list, the filter will be removed after that command (so all tasks will be shown).  Modifying commands are those commands that modify the deadline manager's content (e.g. `add`, `delete`, `edit` and `clear`).

==== Overview

Filter predicates are the core of the `filter` command.  Each filter predicate specifies a testable condition that, for every task, may evaluate to either `true` or `false` (e.g. whether the deadline is earlier than 1/10/2018).  Filter predicates are regarded as "indivisible".

// end::filter-overview[]

[NOTE]
Filter predicates are indivisible because each filter predicate represents a single rule for filtering - for example, a specified field (e.g. deadline) is compared against some specified value (e.g. 1/10/2018).  There is no way to decompose a filter predicate into smaller testable conditions.

*Most of the time, the <<Simplified filter syntax>> is sufficient to find the needed task(s) for most basic use cases.  We recommended that you read that section first and determine if you still need greater expressiveness, before reading the reset of the documentation contained in this guide.*

However, when there are many tasks in the deadline manager and the simplified syntax returns too many results, or when an exact subset of tasks are required for exporting (see the `export` command), the simplified syntax becomes may be too imprecise to use.  For these use cases, the `filter` command also supports a fully-featured expression parser that is extremely expressive.

// tag::filter-simplified[]
==== Simplified filter syntax

Tasks can be filtered by typing `filter` followed by one or more space-separated keywords (e.g. `filter homework`, `filter assignment CS2103`, or `filter badminton utown 3/10/2018`).  Such a filter expression would display only those tasks that contain textual or date fields (i.e. name, deadline, tags, and attachments) that matches **every** keyword (e.g. `filter assignment CS2103` will match a task with name `Assignment 1` **and** tags `CS2103` and `easy`).

Numeric fields such as priority and frequency are not matched because the integer values used for priority and frequency often match many task names and tags too.  To filter by priority and frequency, the field must be specified explicitly (see <<Controlling the field being matched>> below).

[NOTE]
An unquoted keyword can contain only alphanumeric characters, `_`, `-`, `/`, `\`, `.`, and `,`.  To use other characters (including whitespace), the keyword must be placed in quotes (both single (`'`) and double (`"`) quotes work, but the opening and closing quotes must match).

****

Matching of each eligible field:

* When matching task names, a task is considered to match if the specified keyword is a substring (case-insensitive) of the task name (the given keyword need not be a whole word in the task name - e.g. `test` and `case` will both match `Testcase`).
* When matching deadlines, a task is considered to match if its deadline is on or earlier than the specified date.
* When matching tags, a task is considered to match if the specified tag is a substring (case-insensitive) of any tag of the task.
* When matching attachments, a task is considered to match if the specified keyword is a substring (case-insensitive) of a filename of any attachment in the task.

****

Examples:

* `filter homework`
Returns a subset of the current list of tasks that have a name or tag list that contains "homework".  Note that "homework" cannot be interpreted as a valid date, so the deadline field is ignored.

* `filter assignment CS2103`
Returns a subset of the current list of tasks that have a name or tag list that contains "assignment" and a name or tag list that contains "CS2103".  Note that neither "assignment" or "CS2103" can be interpreted as a valid date, so the deadline field is ignored for both keywords.

* `filter badminton utown 3/10/2018`
Returns a subset of the current list of tasks that have a name or tag list that contains "badminton", a name or tag list that contains "utown", and a name, tag list, or deadline that matches "3/10/2018".  Note that any deadline on or before 3 October 2018 will match "3/10/2018".

* `filter 1/10/2018`
Returns a subset of the current list of tasks that have a name, tag list, or deadline on or before 1st October 2018.

// end::filter-simplified[]
// tag::filter-field[]
==== Controlling the field being matched

Each keyword can instead be written as a _full predicate_, which is a string of the following format: `<key><operator><phrase>`. The following diagram is an example of a typical full predicate:

image::FilterUnitDiagramUG.png[width="200"]

Each of the three parts of a full predicate means the following:

* `key` is an alphabetic string that describes the attribute being compared. For example: `priority`, `tag` and `name`.
* `operator` is one of `:`, `=`, `<`, `>`.
* `phrase` is a string that describes what to search (this is called the search phrase, and it is similar to the _keyword_ in the simplified syntax).

As with the simplified syntax, an unquoted `phrase` string can contain only alphanumeric characters, `_`, `-`, `/`, `\`, `.`, and `,`.  To use other characters (including whitespace), the search phrase must be placed in quotes (both single (`'`) and double (`"`) quotes work, but the opening and closing quotes must match).

The operator `:` is known as the *convenience* operator -- it is an alias for the operator that intuitively "does what you expect" for the given `key`.  More details are given below in the context of each key.

// end::filter-field[]

[NOTE]
The `<` and `>` operators are non-strict: Every task that will be shown using `=` will also be shown using `<` or `>`.

[TIP]
This full predicate syntax can be mixed arbitrary with the keyword syntax described in the previous section.  For example, `badminton n:utown 3/10/2018` is allowed.

The following subsections explain the meaning of the operators for each valid key:

===== Name

When `key` is `n` or `name`, the task name is compared.  Comparison is case-insensitive.  The operator `>` tests if the search phrase is contained within the task name.  The operator `<` tests if the task name is contained within the search phrase.  The operator `=` tests if the search phrase is exactly the same as the task name.  The convenience operator is an alias for `>`.

Examples to demonstrate each operator type:

[width="100%",options="header,autowidth"]
|=========================================================
|Task name |Test phrase |Matches ">" |Matches "=" | Matches "<"| Matches ":"
|homework assignment |assign |Yes |No |No |Yes
|exam |exam |Yes |Yes |Yes |Yes
|assignment |homework assignment |No |No |Yes |No
|assignment |homework |No |No |No |No
|Homework Assignment |assign |Yes |No |No |Yes
|Exam |exam |Yes |Yes |Yes |Yes
|Assignment |homework assignment |No |No |Yes |No
|=========================================================

===== Deadline

When `key` is `d`, `due` or `deadline`, the task's due date is compared, and the search phrase is interpreted as a date.  Dates must in the format specified in the _Deadline Format_ section.  The operator `>` tests if the task's due date is on or after the specified due date.  The operator `<` tests if the task's due date is on or before the specified due date.  The operator `=` tests if the task's due date is exactly equal to the specified due date.  The convenience operator is an alias for `<`.

Examples to demonstrate each operator type:

[width="100%",options="header,autowidth"]
|=========================================================
|Task deadline |Test phrase |Matches ">" |Matches "=" | Matches "<"| Matches ":"
|1/10/2018 |20/9/2018 |Yes |No |No |No
|1/10/2018 |1/10/2018 |Yes |Yes |Yes |Yes
|1/10/2018 |15/10/2018 |No |No |Yes |Yes
|=========================================================

===== Priority

When `key` is `p` or `priority`, the task's priority is compared, and the search phrase is interpreted as an integer, representing the priority to be searched.  A priority of zero matches all the tasks with no priority set.  The operator `>` tests if the task has priority at least as high as the specified priority.  The operator `<` tests if the task has priority at most as high as the specified priority.  The operator `=` tests if the task's priority is exactly equal to the specified priority.  The convenience operator is an alias for `>`.  Note that priority 1 is the highest priority, priority 4 is the lowest priority, and tasks without any priority are considered to be of lower priority than priority 4.  In other words, `1 > 2 > 3 > 4 > (no priority)`.

Examples to demonstrate each operator type:

[width="100%",options="header,autowidth"]
|=========================================================
|Task priority |Test phrase |Matches ">" |Matches "=" | Matches "<"| Matches ":"
|2 |4 |Yes |No |No |Yes
|2 |2 |Yes |Yes |Yes |Yes
|2 |1 |No |No |Yes |No
|=========================================================

===== Frequency

When `key` is `f` or `frequency`, the task's frequency (i.e. the number of days between consecutive occurrences of that task) is compared, and the search phrase is interpreted as an integer, representing the frequency to be searched.  A non-recurring task is treated as if it has a frequency that is infinitely large (i.e. `f>100` also includes all non-recurring tasks).  The operator `>` tests if the task has a recurrence interval larger than or equal to the specified number of days.  The operator `<` tests if the task has a recurrence interval smaller than or equal to the specified number of days.  The operator `=` tests if the task has a recurrence interval exactly equal to the specified number of days.  The convenience operator is an alias for `<`.

Examples to demonstrate each operator type:

[width="100%",options="header,autowidth"]
|=========================================================
|Task frequency |Test phrase |Matches ">" |Matches "=" | Matches "<"| Matches ":"
|7 |4 |Yes |No |No |No
|7 |7 |Yes |Yes |Yes |Yes
|7 |14 |No |No |Yes |Yes
|=========================================================

===== Tag

When `key` is `t` or `tag`, the task's tags are compared, and the search phrase is interpreted as a (unordered) set of (substrings of) tags.  Comparison is case-insensitive.  Multiple tags are separated by commas (see examples below).  The operator `>` tests if every specified tag is a substring of a tag of the given task.  The operator `<` tests if every specified tag is a superstring of a tag of the given task.  The operator `=` tests if every specified tag exactly matches a tag of the given task.  The convenience operator is an alias for `>`.

Examples to demonstrate each operator type:

[width="100%",options="header,autowidth"]
|=========================================================
|Task tags |Test phrase |Matches ">" |Matches "=" | Matches "<"| Matches ":"
|easy,CS2103,homework |CS |Yes |No |No |Yes
|easy,CS2103,homework |CS2103 |Yes |Yes |Yes |Yes
|easy,CS2103,homework |CS2103,homework,easy |Yes |Yes |Yes |Yes
|easy,CS2103,homework |CS2103T |No |No |Yes |No
|easy,CS2103,homework |cs |Yes |No |No |Yes
|easy,CS2103,homework |cs2103 |Yes |Yes |Yes |Yes
|=========================================================

===== Attachment

When `key` is `a` or `attachment`, the task's attachments are compared, and the search phrase is interpreted as a (unordered) set of (substrings of) filenames.  Comparison is case-insensitive.  Multiple filenames are separated by commas, in the same way as tags.  The operator `>` tests if every specified filename is a substring of an attachment filename (of the given task).  The operator `<` tests if every specified tag is a superstring of an attachment filename.  The operator `=` tests if every specified tag exactly matches an attachment filename.  The convenience operator is an alias for `>`.
* Any other `key` will cause Deadline Manager to produce an error.

Examples to demonstrate each operator type:

[width="100%",options="header,autowidth"]
|=========================================================
|Task tags |Test phrase |Matches ">" |Matches "=" | Matches "<"| Matches ":"
|"file.txt","Test.java" |Test |Yes |No |No |Yes
|"file.txt","Test.java" |Test.java |Yes |Yes |Yes |Yes
|"file.txt","Test.java" |Test.java,file.txt |Yes |Yes |Yes |Yes
|"file.txt","Test.java" |betterfile.txt |No |No |Yes |No
|"file.txt","Test.java" |test |Yes |No |No |Yes
|"file.txt","Test.java" |test.java |Yes |Yes |Yes |Yes
|=========================================================

[NOTE]
For set-based filter predicates (i.e. tags and attachments), an extension is available to specify that the set of tags (or attachments) in the task must be _exactly_ those tags (or attachments) in the filter predicate (i.e. there should be no extra tags (or attachments) in the task).  See <<Set-based extensions for filter predicates>> for more details.

[TIP]
The behaviour of the simplified syntax mirrors that of the convenience operator.

Examples:

* `filter due<1/10/2018`
Returns a subset of the current list of tasks that have deadlines on or before 1st October 2018.
// TODO: define a subset in glossary

* `filter d=1/10/2018`
Returns a subset of the current list of tasks that have deadlines equal to 1st October 2018.

* `filter d:1/10/2018`
Returns a subset of the current list of tasks that have deadlines on or before 1st October 2018.

* `filter name:Alex`
Returns a subset of the current list of tasks that have a name that contains "Alex" (case-insensitive).

* `filter n:"Alex Tan"`
Returns a subset of the current list of tasks that have a name that contains "Alex Tan" (case-insensitive).

* `filter p=1`
Returns a subset of the current list of tasks that have priority = 1 (highest priority).

* `filter p>3`
Returns a subset of the current list of tasks that have priority = 1, 2, or 3. (Highest priority, second highest priority, or third highest priority.)

* `filter f=1`
Returns a subset of the current list of tasks that recurs daily.

* `filter f<7`
Returns a subset of the current list of tasks that recurs at least once a week.

* `filter t:CS`
Returns a subset of the current list of tasks that has a tag that contains the substring "CS" (case-insensitive).  The task could also contain other tags.

* `filter t=CS2103T`
Returns a subset of the current list of tasks that has the tag "CS2103T" (case-insensitive).  The task could also contain other tags.

* `filter t=CS2103T,CS2101`
Returns a subset of the current list of tasks that has both the tags "CS2103T" and "CS2101" (case-insensitive).  The task could also contain other tags.

* `filter a:hello`
Returns a subset of the current list of tasks that contains an attachment with a filename that contains "hello" (case-insensitive).  The task could also contain other attachments.

* `filter a=Test.java,'Hello world.txt'`
Returns a subset of the current list of tasks that contains the attachments with exact filenames "Test.java" and "Hello world.txt" (case-insensitive).  The task could also contain other attachments.

==== Composing filter predicates

In the simplified filter syntax, multiple space-separated keywords mean that _every_ keyword must match some field in the task, effectively expressing a logical conjunction (i.e. AND).  To allow for full flexibility, logical disjunction (i.e. OR), logical negation (i.e. NOT), and arbitrary compositions of logical operations may also be expressed, and they are described below:

Filter expressions (i.e. the `FILTER_EXPRESSION` strings) are composed from any number of filter predicates, and they create a composite rule to filter against.  The `filter` command is designed to accept arbitrarily complex filter expressions that can be composed from any number of filter predicates. +
The format for `FILTER_EXPRESSION` is defined recursively in the following paragraphs.

`FILTER_EXPRESSION` is a string in the following format:

* `FILTER_PREDICATE` -- This filter expression contains a single filter predicate (each filter predicate can use either the full predicate or the keyword syntax)
* `FILTER_EXPRESSION & FILTER_EXPRESSION` -- This filter expression is a logical conjunction (i.e. AND) of two other filter expressions.  The operator `&` may be substituted with `&&`.
* `FILTER_EXPRESSION | FILTER_EXPRESSION` -- This filter expression is a logical disjunction (i.e. OR) of two other filter expressions.  The operator `|` may be substituted with `||`.
* `! FILTER_EXPRESSION` -- This filter expression is a logical negation (i.e. NOT) of two other filter expressions.
* `( FILTER_EXPRESSION )` -- This filter expression is surrounded by parentheses.

****

Parentheses are used for finer control the order that filter expressions are combined.  By default, `!` has highest precedence (i.e. `!` is applied first), followed by `&`, then followed by `|`.  Parentheses may be nested to arbitrary depth, and in any valid manner.

When no boolean operator (`&`, `|`, or `!`) is specified where one is expected, it is implicitly treated as if an `&` was used.  This allows the simplified syntax to work as it currently does.

When it is unambiguous, whitespace between the operators and filter expressions may be omitted.

****

[TIP]
Intuitively, the syntax for filter expressions mirrors that of arithmetic expressions such as `1+3*4` and `(1+4+6)*2`.

Examples:

* `filter assignment|CS2101`
Returns a subset of the current list of tasks that have a name or tag list that contains "assignment" or "CS2101".

* `filter ! t:CS2101`
Returns a subset of the current list of tasks that do not have the tag "CS2101".

* `filter n:assignment | (p:3 & t:CS2101)`
Returns a subset of the current list of tasks that have a name that contains "assignment", or have priority at least 3 and contains tag "CS2101".

* `filter n:assignment||(p:3 t:CS2101)`
Returns a subset of the current list of tasks that have a name that contains "assignment", or have priority at least 3 and contains tag "CS2101".

* `filter !n:homework||(p:3 t:CS2101)`
Returns a subset of the current list of tasks that have a name that does not contain "homework", or have priority at least 3 and contains tag "CS2101".

// tag::filter-set[]
==== Set-based extensions for filter predicates

For fields that represent a collection (i.e. tags and attachments), it is also possible to filter only tasks which **do not contain** other tags or attachments apart from those specified.  To do so, we introduce a set operator as per the diagram below:

image::FilterUnitDiagramSetUG.png[width="250"]

The part that was called `operator` previously is called the `field operator` here, and it retains its original meaning.  The `set operator` introduced here specifies how the specified set (in the filter predicate) compares to the task's set (of tags or attachments).

****

Meaning of the set operator:

* The operator `>` tests if every item in the specified set is contained within the task's set.  The operator `<` tests if every item in the task's set is contained within the specified set.  The operator `=` tests if the two sets are equivalent (meaning that every item in the task's set is contained within the specified set and vice-versa).  The convenience operator is an alias for `>`.

****

[TIP]
When comparing a set-based field without using this dual-operator syntax, the set based operator used is effectively the convenience operator.  (In other words, `<key><operator><phrase>` is equivalent to `<key>:<operator><phrase>`.)

Examples to demonstrate each operator type (using the tag field):

[width="100%",options="header,autowidth"]
|=========================================================
|Task tags |Test phrase |Matches ">:" |Matches "=:" | Matches "<:"| Matches "::"
|easy,CS2103,homework |CS2103 |Yes |No |No |Yes
|easy,CS2103,homework |easy,CS2103,homework |Yes |Yes |Yes |Yes
|easy,CS2103,homework |CS2103,homework,easy |Yes |Yes |Yes |Yes
|CS2103 |CS2103,homework |No |No |Yes |No
|easy,CS2103,homework |cs2103 |Yes |No |No |Yes
|easy,CS2103,homework |cs |Yes |No |No |Yes
|=========================================================

[TIP]
The set operator works in the same way as the above table for the attachment field as well.

Examples:

* `filter t=:CS`
Returns a subset of the current list of tasks that has a tag that contains the substring "CS" (case-insensitive).  The task cannot contain any tags that do not have the substring "CS".

* `filter a=:Hello`
Returns a subset of the current list of tasks that has an attachment that contains the substring "Hello" (case-insensitive).  The task cannot contain any attachments that do not have the substring "Hello".

* `filter t==CS2103T,CS2101`
Returns a subset of the current list of tasks that has both the tags "CS2103T" and "CS2101" (case-insensitive).  The task cannot contain any other tags.

* `filter t:=CS2103T`
Returns a subset of the current list of tasks that has the tag "CS2103T" (case-insensitive).  The task could also contain other tags.  (This is equivalent to `filter t=CS2103T`.)

* `filter t<:CS`
Returns a subset of the current list of tasks that do not have any tags that do not contain the substring "CS" (case-insensitive).  The task need not have any tags that contain the substring "CS", and it could have no tags at all.  This is usually used in conjunction with other filter predicates to constrain the filtered list to be exported.

// end::filter-set[]
// end::filter[]

//TODO: Sidhant
// tag::sort[]
=== Sorting a list of tasks : `sort`

Sorts the lists of all the tasks which the user is currently viewing. Generally meant to be used in combination with `filter`. +

When this command is used, Deadline Manager will sort all the currently displayed tasks according to the user specified comparison method. +
Sort comparators are the core of the `sort` command.  Each sort comparator specifies a particular attribute (Example - `name`, `priority`) and a comparison direction, i.e ascending or descending.

The entire sorting command is composed of a chain of sort comparators. This chain helps the user to define which tasks to show earlier and which ones to show latter. +

[TIP]
The sort command results in a stable sort, i.e if two deadlines are equal according to the sort comparators then their relative order before the sort command and after the sort command remains the same.

****

What this means is that in case two tasks are in tie according to the first comparator, then the decision to place which task first is determined by the next comparator, and so on.

****

Format: `sort SORT_COMPARATOR [SORT_COMPARATOR]...` +

****
* Format of a `SORT_COMPARATOR`: `(n|name|d|due|p|priority|f|frequency)(<|>)` OR `(t|tag)(<|>){TAG1 TAG2 ...}`
* In the above format `|` refers to an OR. `TAG1` and `TAG2` are shown as example of tags that the user can input.
* `<` stands for sorting in ascending order and `>' stands for sorting in descending order.
* Sorts the list by the 1st comparator, in case of ties, it sorts by 2nd comparator and so on.
* Meaning of the operators for each valid key:
** When `key` is `n` or `name`, the task name is compared. Comparison is case-insensitive.
** When `key` is `d` or `due` or `deadline`, the task's due date is compared.
** When `key` is `p` or `priority`, the task's priority is compared. Note that 1 is the highest priority and 4 is the lowest priority.
** When `key` is `f` or `frequency`, the task's frequency (i.e. the number of days between consecutive occurrences of that task) is compared.  A non-recurring task is treated as if it has a frequency of positive infinity.
** When `key` is `t` or `tag`, the task's tags are compared. In case `<` is used, it means `TAG1` is placed eariler in the sorted order as compared to `TAG2` and so on. For `>` it is vice-versa.
[NOTE]
For sorting by tags the user has to specify which tags are more important and which are less important.
** Any other `key` will cause Deadline Manager to produce an error.
****
Examples:

* `sort n>` +
Sorts the current list of tasks in view in descending order by name, where sorting is done in alphabetical order.

[sortdemo1]
.Result of "sort n<" command
[#img-sortdemo1]
[caption="Figure 3.10.1: "]
image::userguide/sortdemo_1.png[SortDemo1, width="900"]

* `sort due< name>` +
Sorts the current list of tasks in view in ascending order by due date, where ties are broken by descending order of names.
* `sort priority<` +
Sorts the current list of tasks in view in ascending order by priority.
* `sort frequency<` +
Sorts the current list of tasks in view in ascending order by frequency.
* `sort tag<{ cs2100 family cs2103t }` +
Sorts the current list of tasks in view in ascending order by tags. In this case all the tasks with the tag `cs2100` will be placed
before those tasks with the tag `family`, finally followed by those tasks with the tag `cs2103t`.
* `sort n< tag<{` +
This is invalid syntax since the curly braces have not been closed. +

[sortdemo2]
.Result of "sort n< tag<{" command
[#img-sortdemo2]
[caption="Figure 3.10.2: "]
image::userguide/sortdemo_2.png[SortDemo1, width="600"]
Figure 3.10.2 above shows the error message when user feeds in an invalid command.

[TIP]
In case a task does not belong to any of the tags mentioned in the sort comparator it will be placed at the bottom of the sorted list.

[TIP]
In case a task contains more than one tag specified in the sort comparator, then it will be sorted according to those tags first which place it former in the sorted list.

// end::sort[]


//TODO: Ranald
// tag::attachment[]
=== Managing attachments of a task : `attachment`
Allows the user to add, list, delete and retrieve files associated with a specific task. +
Deadline manager does not make a copy or backup the files added. Only the location of the files are stored by Deadline Manager. Hence, it is possible that the file might have been modified, renamed, moved or deleted without Deadline Manager's knowledge. As such, there is no guarantee for a file associated with a specific task to always exist.  +
After the command is successfully executed, all the tasks in Deadline Manager will be listed. +
Format (in general): `INDEX ACTION [p/"FILEPATH"] [n/"FILENAME"]`

More specific formats for each actions are listed below.

* Format for *Add* Actions: `attachment INDEX add p/"FILEPATH"`

* Format for *Delete* Actions: `attachment INDEX delete n/"FILENAME"`

* Format for *List* Actions: `attachment INDEX list`

* Format for *Get* Actions: `attachment INDEX get n/"FILENAME" p/"FILEPATH"`
[TIP]
The application does not allow adding more than one file with the same filename to the same task, even if they are in different locations on the computer. For this application, filename includes the file extension as well.
****
*  Modify and manages the attachments of the task at the specified INDEX. The index refers to the index number shown in the displayed task list. The index must be a positive integer 1, 2, 3, …​
* `ACTION` is either `add`, `list`, `delete` or `get`

* For `add` actions, the `FILEPATH` argument is required to denote the file you intend to attach to the task. A file must exist at the `FILEPATH` specified. The `FILEPATH` must be enclosed in quotation marks. For example: `"D:/Documents/HelloWorld.txt"`

* For `list` actions, no additional arguments are required.

* For `delete` actions, the `FILENAME` argument is required to represent the file to delete. The `FILENAME` must be enclosed in quotation marks. For example: `"Hello World.docx"`.

* For `get` actions, the `FILENAME` argument is required to represent the file to retrieve and the `FILEPATH` argument is required to denote the destination you want the file to be exported to. If there is an existing file at `FILEPATH`, it would be overwritten without warning. The `FILEPATH` and `FILENAME` must be enclosed in quotation marks, similar to the arguments in `add` and `delete` actions. Do note that `FILEPATH` should be a path to a file, not a folder in the computer.
****

[TIP]
To avoid ambiguity, it is recommended to use quotation marks when specifying a `FILEPATH` or `FILENAME`. Those that are not enclosed in quotations will still be parsed. However, the correct behaviour is not guaranteed.
[TIP]
If your filename contains double quotation marks `"` but not single quotation marks `'`, you may enclose the filename with single quotation marks `'` instead. However, the application will not be able to work with files that have both double quotation marks and single quotation marks.

Examples:

* Add: `attachment 1 add p/"D:\Documents\Hello World.docx"` +
Adds an attachment located at "D:\Documents\Hello World.docx" to the 1st task currently listed in the deadline manager. (Tip: You can list all tasks using the `list` command.)

[attachmentdemo1]
.Result of Attachment Command with Add Action
[#img-attachmentdemo1]
[caption="Figure 3.10.1: "]
image::userguide/attachmentdemo_1.png[AttachmentDemo2, width="600"]
Figure 3.10.1 above shows an expected result message if the command is successfully executed by Deadline Manager for the example command.


[attachmentdemo2]
.Attachment Label after an attachment is added to a file
[#img-attachmentdemo2]
[caption="Figure 3.10.2: "]
image::userguide/attachmentdemo_2.png[AttachmentDemo2, width="300"]
Figure 3.10.2 above shows the label that would be displayed along with the task after an attachment is added. The label will contain the file name.


* List: `attachment 1 list` +
Lists all attachments currently associated with the 1st task in the deadline manager.

[attachmentdemo3]
.Result of Attachment Command with List Action
[#img-attachmentdemo3]
[caption="Figure 3.10.3: "]
image::userguide/attachmentdemo_3.png[AttachmentDemo3, width="300"]
Figure 3.10.3 above shows an expected result message if the command is successfully executed by Deadline Manager for the above command with the List Action.


* Get: `attachment 2 get p/"D:\Documents\TaskAttachments.zip" n/"Assignment.zip"` +
Saves an attachment named "Assignment.zip" of the 2nd task in the deadline manager to "D:\Documents\TaskAttachments.zip"


[attachmentdemo4]
.Result of Attachment Command with Get Action
[#img-attachmentdemo4]
[caption="Figure 3.10.4: "]
image::userguide/attachmentdemo_4.png[AttachmentDemo4, width="600"]
Figure 3.10.4 above shows an expected result message if the command is successfully executed by Deadline Manager for the above command with the Get action.


[attachmentdemo5]
.Attachment will be saved to the designated location after the Get Action
[#img-attachmentdemo5]
[caption="Figure 3.10.5: "]
image::userguide/attachmentdemo_5.png[AttachmentDemo5, width="600"]
Figure 3.10.5 above shows that you can expect to see the attachment appear in the designated location after the Get action.

* Delete: `attachment 1 delete n/"Hello World.docx"`
Removes the association of the attachment named "Hello World.docx" with the 1st task in the deadline manager.

[attachmentdemo6]
.Result of Attachment Command with Delete Action
[#img-attachmentdemo6]
[caption="Figure 3.10.6: "]
image::userguide/attachmentdemo_6.png[AttachmentDemo6, width="400"]
Figure 3.10.6 above shows an expected result message if the command is successfully executed by Deadline Manager for the above command with the Delete action.

[NOTE]
The <<Importing a set of tasks: `import`, `import`>>, <<Exporting a set of tasks: `export`, `export`>> commands do *NOT* support backing up attachments. However they will keep a link to the attachments path if any.

[NOTE]
The <<Sorting a list of tasks : `sort`, `sort`>> command currently does *NOT* support sorting tasks by their attachments. Support for this commands may be added in future releases of the application.
// end::attachment[]


//TODO: Add a picture on what I mean by "currently displayed"
// tag::export[]
=== Exporting a set of tasks: `export`
Exports the tasks that is currently displayed by the Deadline Manager. The tasks will be saved as a file at the provided `FILEPATH` location.

Deadline Manager provides two different formats to export in.

. eXtensible Markup Language (XML) format: XML is a format that Deadline Manager is fully compatible with. If exported as XML format, tasks can be <<Importing a set of tasks: `import`, imported>> back into another copy of Deadline Manager.

. Comma Separated Values (CSV) format: CSV is a format that is supported by most calendar applications. If exported as CSV format, tasks can be imported into other applications like Google Calendar. Currently, Deadline Manager can only export names and deadlines of tasks.

Format: `export [csv] p/FILEPATH [r/overwrite]`

****
* If the `csv` option is specified, Deadline Manager will export tasks in CSV format. Otherwise, by default, it will export in XML format.

* `FILEPATH` refers to a location on your computer, and the `FILEPATH` provided should be enclosed within quotes (`"`). You may provide a relative location (`tasks.xml`) or an absolute location (`C:\Folder\tasks.xml`). Deadline Manager will attempt to export to the specified location.

[TIP]
To avoid ambiguity, it is recommended to use quotation marks when specifying a `FILEPATH`. `FILEPATHs` not enclosed in quotations will still be parsed, however correct behaviour is not guaranteed.

* If there is an existing file at the provided location, the write command will fail, in order to protect your data.

[TIP]
You can override the default behaviour by specifying r/overwrite. This will allow you to overwrite files even if they already exist. Use with caution so as not to overwrite important data.

****

Examples:

* `export p/cs2101.xml` +
Creates and exports tasks to `cs2101.xml` in the same folder as Deadline Manager. This file can be used in <<Importing a set of tasks: `import`, import>> later.

The following is a step-by-step guide on how the export command behaves.
[exportdemo1]
.Command box.
[#img-exportdemo1]
[caption="Figure 3.9.1: "]
image::userguide/exportdemo_1.PNG[ExportDemo, width="790"]
In Figure 3.9.1 above, the user enters the `export p/cs2101.xml` command into the command box.

[exportdemo2]
.Result of export command
[#img-exportdemo2]
[caption="Figure 3.9.2: "]
image::userguide/exportdemo_2.png[ExportDemo2, width="790"]
In Figure 3.9.2 above, after the user presses enter, Deadline Manager exports the file and display a success message. The exported file is located at cs2101.xml, and contains the tasks displayed in the deadline manager, namely "CS2101 Oral Presentation" in the screenshot above.

* `export p/cs2101.txt` (Exports a file successfully) +
  `export p/cs2101.txt` +
Fails and returns an error as `cs2101.txt` already exists when the second command is run. In order to protect your data, the second export command fails.

[exportdemo3]
.Sample error message
[#img-exportdemo3]
[caption="Figure 3.9.3: "]
image::userguide/exportdemo_3.png[ExportDemo3, width="790"]
Figure 3.9.3 above shows the error message when the user attempts to export to a file that already exists. Deadline Manager will not overwrite any existing file so as to protect your data.

[TIP]
You can overwrite the file by specifying r/overwrite. The command would be `export p/cs2101.txt r/overwrite` in this case.

* `export csv p/cs2103.csv` +
Creates and exports tasks to `cs2103.csv` as CSV format. This file is compatible with most calendar applications and can be imported into Google Calendar.

* `export p/"C:\Documents\cs2103.txt"` +
Creates and exports tasks to `cs2103.txt` in the `C:\Documents` folder.
// end::export[]

// tag::import[]
=== Importing a set of tasks: `import`
Imports tasks that were previously generated by an export command. Deadline Manager will attempt to retrieve tasks from the provided `FILEPATH` location.

Format: `import p/FILEPATH [r/all | r/overwrite | r/skip]`

****
* `FILEPATH` refers to a location on your computer, and the `FILEPATH` provided should be enclosed within quotes (`"`). You may provide a relative location (`tasks.xml`) or an absolute location (`C:\Folder\tasks.xml`). Deadline Manager will attempt to import from the specified location.

[TIP]
To avoid ambiguity, it is recommended to use quotation marks when specifying a `FILEPATH`. `FILEPATHs` not enclosed in quotations will still be parsed, however correct behaviour is not guaranteed.

* Additionally, the file must be in a readable XML format.

[NOTE]
Currently, Deadline Manager does not support importing from a CSV file. This feature will be made available in v2.0.


****

Optional commands can provided to specify what Deadline Manager should do when there is an import conflict.

[NOTE]
An import conflict occurs when you try to import a task, but a similar task already exists in your Deadline Manager. When this happens, Deadline Manager needs to know what you want to do with these tasks.

You can input either one of three commands to specify how to resolve an import conflict:

* `r/all`: Imports the new task, keeping both the existing and incoming tasks.
* `r/overwrite`: Imports the new task, replacing the existing task.
* `r/skip`: Does not import the conflicting task, keeping the existing task instead.

[TIP]
If you do not specify any command, Deadline Manager uses `r/skip` by default, i.e. it will ignore new tasks that cause import conflicts.

Examples:

* (Assuming that we have previously exported to `cs2101.xml`) +
`import p/cs2101.xml r/all` +
Imports all tasks from `cs2101.xml`. Deadline Manager will save all tasks, even if duplicates already exist.

[importdemo2]
.User prepares to import from cs2101.xml
[#img-importdemo2]
[caption="Figure 3.10.1: "]
image::userguide/importdemo_2.png[ImportDemo2, width="790"]
In Figure 3.10.1, we assume that the user has previously exported to `cs2101.xml`. `cs2101.xml` contains another copy of "CS2101 Oral Presentation". The user now attempts to import from `cs2101.xml`.

[importdemo3]
.Result of import command with the r/all command
[#img-importdemo3]
[caption="Figure 3.10.2: "]
image::userguide/importdemo_3.png[ImportDemo3, width="790"]
Figure 3.10.2 shows the success message after importing from cs2101.xml. Note that, as the r/all command is used, both copies of "CS2101 Oral Presentation" are saved.

*
`import p/cs2101.xml` +
Imports all tasks from `cs2101.xml`. Since the r/all parameter is not specified, if an incoming task already exists in Deadline Manager, it is skipped.

[importdemo4]
.Result of import command with no additional parameters
[#img-importdemo]
[caption="Figure 3.10.3: "]
image::userguide/importdemo_4.PNG[ImportDemo4, width="790"]
Figure 3.10.3 shows the success message after importing from `cs2101.xml`. As `cs2101.xml` contains a duplicate copy of "CS2101 Oral Presentation", nothing new is imported.

* `import p/"C:\Documents\cs2101.xml" r/all` +
Imports all tasks from `C:\Documents\cs2101.xml`. Deadline Manager will save all tasks, even if duplicates already exist.
// end::import[]

=== Deleting a task : `delete`

Deletes the specified task from the deadline manager. +
Format: `delete INDEX`

****
* Deletes the task at the specified `INDEX`.
* The index refers to the index number shown in the displayed task list.
* The index *must be a positive integer* 1, 2, 3, ...
****

Examples:

* `list` +
`delete 2` +
Deletes the 2nd task in the deadline manager.
* `filter OP1 Assignment` +
`delete 1` +
Deletes the 1st task in the results of the `filter` command.

//TODO: Ranald or Sidhant
=== Selecting a task : `select`

Selects the task identified by the index number used in the displayed task list. +
Format: `select INDEX`

****
* Selects the task and loads details about the task at the specified `INDEX`.
* The index refers to the index number shown in the displayed task list. The index must be a positive integer 1, 2, 3, …​
****

Examples:

* `list` +
`select 2` +
Selects the 2nd task in the deadline manager.
* `filter Assignment` +
`select 1` +
Selects the 1st task in the results of the `filter` command.

=== Listing entered commands : `history`

Lists all the commands that you have entered in reverse chronological order. +
Format: `history`

[NOTE]
====
Pressing the kbd:[&uarr;] and kbd:[&darr;] arrows will display the previous and next input respectively in the command box.
====

// tag::undoredo[]
=== Undoing previous command : `undo`

Restores the deadline manager to the state before the previous _modifying_ command was executed. +
Format: `undo`

[NOTE]
====
Modifying commands: those commands that modify the deadline manager's content (e.g. `add`, `delete`, `edit` and `clear`).
====

Examples:

* `delete 1` +
`list` +
`undo` (reverses the `delete 1` command) +

* `select 1` +
`list` +
`undo` +
The `undo` command fails as there are no undoable commands executed previously.

* `delete 1` +
`clear` +
`undo` (reverses the `clear` command) +
`undo` (reverses the `delete 1` command) +

=== Redoing the previously undone command : `redo`

Reverses the most recent `undo` command. +
Format: `redo`

Examples:

* `delete 1` +
`undo` (reverses the `delete 1` command) +
`redo` (reapplies the `delete 1` command) +

* `delete 1` +
`redo` +
The `redo` command fails as there are no `undo` commands executed previously.

* `delete 1` +
`clear` +
`undo` (reverses the `clear` command) +
`undo` (reverses the `delete 1` command) +
`redo` (reapplies the `delete 1` command) +
`redo` (reapplies the `clear` command) +
// end::undoredo[]



=== Clearing all entries : `clear`

Clears all task entries from the deadline manager. +
Format: `clear`

=== Exiting the program : `exit`

Exits the program. +
Format: `exit`

=== Saving the data

Deadline manager data are saved in the hard disk automatically after any command that changes the data. +
There is no need to save manually.

[NOTE]
Attachments are merely linked in the deadline manager. A separate copy of the file will not be stored. If the original attachment file has been deleted, deadline manager will fail to retrieve it.

// tag::dataencryption[]
//=== Encrypting data files `[coming in v2.0]`

//_{explain how the user can enable/disable data encryption}_
// end::dataencryption[]

== FAQ

*Q*: How do I transfer my data to another Computer? +
*A*: Install the app in the other computer and overwrite the empty data file it creates with the file that contains the data of your previous deadline manager folder.
// tag::faqfilepath[]
*Q*: How do I obtain the `FILEPATH` of a particular file in my Computer? +
*A*: For `Windows 10` users, you may follow the following steps using the `File Explorer` application on your Computer in order to obtain the `FILEPATH`:

. Navigate to the file you intend to obtain the `FILEPATH` of using the `File Explorer` application.
. Select the file which you intend to obtain the `FILEPATH` of.
. Click on `Home` near the top left corner of the `File Explorer` application.
. Click on the `Copy path` button as indicated in Figure 4.1 below. The `FILEPATH` will then be copied onto your clipboard.
. Go to the command box of Deadline Manager and paste the `FILEPATH` as required.

[qnafilepath1]
.`Copy path` button within the `File Explorer` application
[#img-qnafilepath1]
[caption="Figure 4.1: "]
image::userguide/qna_filepath_1.png[QnAFilepath1, width="600"]
Figure 4.1 above indicates which button should be clicked in order to obtain the `FILEPATH`. The `FILEPATH` should look something similar to `"D:\Documents\123 p\Assignment.docx"`. You can use this for the `FILEPATH` argument in both <<Importing a set of tasks: `import`, `import`>>, <<Exporting a set of tasks: `export`, `export`>> and <<Managing attachments of a task : `attachment`, `attachments`>>.
// end::faqfilepath[]

== Command Summary

* *Add* `add n/NAME d/DEADLINE [f/FREQUENCY] [p/PRIORITY] [t/TAG]...` +
e.g. `add n/CS2103 Tutorial d/11/10/2018 f/7 p/2 t/java t/hard`

* *Attachment (Add)* : `attachment INDEX add p/"FILEPATH"`

* *Attachment (Delete)* : `attachment INDEX delete n/"FILENAME"`

* *Attachment (List)* : `attachment INDEX list`

* *Attachment (Retrieve)* : `attachment INDEX get n/"FILENAME" p/"FILEPATH"`
e.g. `attachment 2 get p/"C:\Documents\TaskAttachments.zip" n/"Assignment.zip"`

* *Clear* : `clear`

* *Complete*: `complete INDEX`

* *Delete* : `delete INDEX` +
e.g. `delete 3`

* *Edit* : `edit INDEX [n/NAME] [d/DEADLINE] [t/TAG]...` +
e.g. `edit 2 n/CS2103 Assignment 2 t/easy`

* *Exit* : `exit`

* *Export* : `export FILEPATH`

* *Filter* : `filter FILTER_EXPRESSION`
e.g. `filter due<1/10/2018`

* *Help* : `help`

* *History* : `history`

* *Import* : `import FILEPATH`

* *List* : `list`

* *Redo* : `redo`

* *Search* : `search FILTER_EXPRESSION`
e.g. `search due<1/10/2018`

* *Select* : `select INDEX` +
e.g.`select 2`

* *Sort* : `sort SORT_COMPARATOR [SORT_COMPARATOR]...` +
e.g. `sort due< name>`

* *Undo* : `undo`


== Glossary
* Conjunction: A composite statement (i.e. predicate) that is true when two given statements are both true, or false otherwise.
* Disjunction: A composite statement (i.e. predicate) that is true when any of two given statements are true, or false otherwise.
* File Path: A string that defines the unique location of a file in the file system. The file path provided to Deadline Manager should include the file extension as well. You may like to refer to the <<FAQ, FAQ>> for instructions on how to obtain the File Path of a file on your computer.
* Negation: A composite statement (i.e. predicate) that is true when the given statement is false, or false otherwise.
* Subset: A part of a larger group of related things.
